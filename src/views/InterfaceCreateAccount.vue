<template>
  <InterfaceForm :title="$t('common.createAccount')">
    <Notice :symbol="mdiHelpCircleOutline">
      {{ $t("interfaceCreateAccount.toCreateAccount") }}
    </Notice>

    <TextInput
      v-model="state.newBalance"
      :error="state.newBalanceError"
      :label="$t('interfaceCreateAccount.initialBalance')"
      :min="1"
      :suffix="Unit.Hbar"
      :valid="validBalance"
      has-input
      show-validation
    />

    <TextInput
      v-model="state.publicKey"
      :autocomplete-disabled="true"
      :error="state.keyError"
      :label="$t('interfaceCreateAccount.publicKey')"
      :spellcheck-disabled="true"
      :valid="state.isPublicKeyValid"
      show-validation
    />

    <template v-slot:footer>
      <Button
        :busy="state.isBusy"
        :disabled="!state.isPublicKeyValid || !validBalance"
        :label="$t('common.createAccount')"
        @click="handleShowSummary"
      />
    </template>

    <ModalSuccess
      v-model="state.modalSuccessState"
      @action="handleModalSuccessAction"
      @dismiss="handleModalSuccessDismiss"
    >
      <i18n path="modalSuccess.createdAccount">
        <strong>{{ state.account }}</strong>
        <strong>{{ state.newBalance }}</strong>
      </i18n>
    </ModalSuccess>

    <ModalFeeSummary
      v-model="state.summaryModalIsOpen"
      :amount="summaryAmount"
      :items="summaryItems"
      account=""
      tx-type="createAccount"
      @submit="handleCreateAccount"
    />
  </InterfaceForm>
</template>

<script lang="ts">
import { BigNumber } from "bignumber.js";
import { computed, createComponent, onMounted, reactive, SetupContext, watch } from "@vue/composition-api";
import { mdiHelpCircleOutline } from "@mdi/js";

import TextInput from "../components/TextInput.vue";
import Button from "../components/Button.vue";
import InterfaceForm from "../components/InterfaceForm.vue";
import { actions, getters, store } from "../store";
import ModalFeeSummary, { Item } from "../components/ModalFeeSummary.vue";
import { Unit } from "../units";
import Notice from "../components/Notice.vue";
import { formatHbar } from "../formatter";
import ModalSuccess, { State as ModalSuccessState } from "../components/ModalSuccess.vue";
import { writeToClipboard } from "../clipboard";
import { LoginMethod } from "../wallets/Wallet";

interface State {
    newBalance: string;
    publicKey: string;
    isBusy: boolean;
    summaryModalIsOpen: boolean;
    keyError: string;
    newBalanceError: string;
    account: string;
    isPublicKeyValid: boolean;
    modalSuccessState: ModalSuccessState;
}

let estimatedFeeHbar: BigNumber | null = null;
let estimatedFeeTinybar: BigNumber | null = null;

async function updateFees(): Promise<void> {
    estimatedFeeHbar = await getters.estimatedFeeHbar();
    estimatedFeeTinybar = await getters.estimatedFeeTinybar();
}

async function isPublicKeyValid(key: string): Promise<boolean> {
    try {
        // eslint-disable-next-line sonarjs/no-duplicate-string
        const { Ed25519PublicKey } = await import("@hashgraph/sdk");

        Ed25519PublicKey.fromString(key);
        return true;
    } catch (error) {
        // The exception message changes depending on the input
        if (error.message === `invalid public key: ${key}`) {
            return false;
        }

        throw error;
    }
}

export default createComponent({
    name: "InterfaceCreateAccount",
    components: {
        TextInput,
        InterfaceForm,
        Button,
        ModalSuccess,
        Notice,
        ModalFeeSummary
    },
    setup(_: object | null, context: SetupContext) {
        const state = reactive<State>({
            newBalance: "",
            publicKey: "",
            isBusy: false,
            summaryModalIsOpen: false,
            keyError: "",
            newBalanceError: "",
            account: "",
            isPublicKeyValid: false,
            modalSuccessState: {
                isOpen: false,
                hasAction: true,
                actionLabel: "Copy Account ID"
            }
        });

        watch(async() => {
            state.isPublicKeyValid = await isPublicKeyValid(state.publicKey);
        });

        // Just for display in modal title
        const summaryAmount = computed(() => formatHbar(new BigNumber(state.newBalance)));

        const validBalance = computed(() => !isNaN(parseInt(summaryAmount.value, 10)));

        const summaryItems = computed(() => [
            {
                description: context.root
                    .$t("interfaceCreateAccount.initialBalance")
                    .toString(),
                value: validBalance.value ?
                    new BigNumber(state.newBalance) :
                    new BigNumber(0)
            },
            {
                description: context.root
                    .$t("common.estimatedFee")
                    .toString(),
                value: estimatedFeeHbar
            }
        ] as Item[]);

        // eslint-disable-next-line sonarjs/cognitive-complexity
        async function handleCreateAccount(): Promise<void> {
            state.isBusy = true;

            if (store.state.wallet.session == null) {
                throw new Error(context.root
                    .$t("common.error.nullAccountOnInterface")
                    .toString());
            }

            if (estimatedFeeTinybar == null) {
                throw new Error(context.root.$t("common.estimatedFeeError").toString());
            }

            const client = store.state.wallet.session.client;

            const { HederaError, Status } = await import("@hashgraph/sdk");

            try {
                // The new wallet's initial balance
                const { Hbar } = await import("@hashgraph/sdk");
                const newBalanceTinybar = Hbar.of(state.newBalance);
                const _estimatedFeeTinybar = Hbar.fromTinybar(estimatedFeeTinybar);

                // The current user's balance
                const balanceTinybar =
                        store.state.wallet.balance == null ?
                            new Hbar(0) :
                            Hbar.fromTinybar(store.state.wallet.balance);

                const {
                    AccountCreateTransaction,
                    Ed25519PublicKey
                } = await import("@hashgraph/sdk");

                const key = Ed25519PublicKey.fromString(state.publicKey);
                // eslint-disable-next-line max-len
                const maxTxFeeTinybar = Hbar.fromTinybar(await getters.maxFeeTinybar(balanceTinybar.minus(newBalanceTinybar.plus(_estimatedFeeTinybar)).asTinybar()));

                const accountIdIntermediate = (
                    await (
                        await new AccountCreateTransaction()
                            .setInitialBalance(newBalanceTinybar)
                            .setMaxTransactionFee(maxTxFeeTinybar)
                            .setKey(key)
                            .build(client)
                            .execute(client)
                    ).getReceipt(client)
                ).getAccountId();

                // Handle undefined
                if (accountIdIntermediate == null) {
                    throw new Error(context.root
                        .$t("common.error.invalidAccount")
                        .toString());
                }

                // state.accountIdIntermediate must be AccountID
                // get shard, realm, state.account separately and construct a new object
                state.account = `${accountIdIntermediate.shard}.${accountIdIntermediate.realm}.${accountIdIntermediate.account}`;

                // If creating state.account succeeds then remove all the error
                state.newBalanceError = "";

                // Refresh Balance
                await actions.refreshBalanceAndRate();

                state.modalSuccessState.isOpen = true;
            } catch (error) {
                if (error instanceof HederaError) {
                    const errorMessage = (
                        await actions.handleHederaError({
                            error,
                            showAlert: false
                        })
                    ).message;

                    // Small duplication of effort to assign errorMessage to correct TextInput
                    switch (error.code) {
                        case Status.InsufficientAccountBalance.code:
                        case Status.InsufficientPayerBalance.code:
                            state.newBalanceError = errorMessage;
                            break;
                        default:
                            if (errorMessage !== "") {
                                actions.alert({
                                    message: errorMessage,
                                    level: "warn"
                                });
                            } else {
                                throw error; // Unhandled Error Modal will open
                            }
                    }
                } else if (
                    error.name === "TransportStatusError" &&
                    store.state.wallet.session.wallet.getLoginMethod() ===
                        LoginMethod.Ledger
                ) {
                    await actions.handleLedgerError({
                        error,
                        showAlert: true
                    });
                } else {
                    throw error;
                }
            } finally {
                state.isBusy = false;
            }
        }

        async function handleModalSuccessAction(): Promise<void> {
            // Copy created AccountID
            await writeToClipboard(state.account);
            actions.alert({
                level: "info",
                message: context.root
                    .$t("modalSuccess.copiedAccountID")
                    .toString()
            });
        }

        function handleModalSuccessDismiss(): void {
            state.modalSuccessState.isOpen = false;
            state.isBusy = false;
            state.publicKey = "";
            state.newBalance = "";
            state.account = "";
        }

        function handleShowSummary(): void {
            state.summaryModalIsOpen = true;
        }

        onMounted(updateFees);

        return {
            state,
            summaryAmount,
            summaryItems,
            validBalance,
            handleCreateAccount,
            handleShowSummary,
            handleModalSuccessAction,
            handleModalSuccessDismiss,
            Unit,
            mdiHelpCircleOutline
        };
    }
});
</script>
